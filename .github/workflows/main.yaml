# Uncomment required Jobs and Steps as needed

---
name: Push
run-name: ${{ github.actor }} - ${{ github.event.head_commit.message }} 🏗️
on:
  push:
    branches:
      - prod
      - stg
      - dev
  schedule: # A regular sync to prevent drifts.
    - cron: "0 8 * * 1" # every day at 8am UTC Monday # https://crontab.guru/#0_8_*_*_*
  workflow_dispatch: {}
env:
    APP_NAME: ${{ vars.APP_NAME }}        # Set via GitHub Secrets and variables on a repo level
#   AWS_REGION: ${{ vars.AWS_REGION }} # Set via GitHub Secrets and variables on a org level
#   AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}  # Set via GitHub Secrets and variables on a org level
#   ROLE_ARN: ${{ secrets.ROLE_ARN }}     # Set via GitHub Secrets on a repo level
jobs:
  tests:
    name: Run Tests
    permissions:
      contents: read
      id-token: write # This is required for requesting the JWT
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }} # Set via GitHub Secrets and variables on an org level
          role-to-assume: ${{ vars.AWS_ECR_ROLE_ARN }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - uses: azure/setup-helm@v4.2.0
        with:
          version: "latest" # default is latest (stable)
      - name: Helm Lint
        run: |
          helm dependency build helm/
          helm lint helm/ --strict

      - name: Setup Node.js for commitlint
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"
      - name: Check if the commit message is properly formatted
        run: |
          npm install -g @commitlint/config-conventional
          npx commitlint --config ".githooks/.commitlintrc.yml" --last --verbose

      - name: Other tests
        run: echo insert other tests here

      # - name: Run terraform formatting
      #   run: terraform fmt -recursive  -check

  git-tag-release:
    name: Create a semanitc git tag if needed
    runs-on: ubuntu-latest
    needs:
      - tests
    permissions:
      contents: write # to be able to publish a GitHub release
    outputs:
      should-run-build: ${{ steps.decision.outputs.should-run-build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"
      - name: Release if needed
        id: decision
        # env:
        # GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # TODO / remove this
        run: |
          # Check if there are any changes that are relevant for the release
          output=$(npx semantic-release --dry-run)
          if echo "$output" | grep -q "Published release"; then
            npx semantic-release
            echo "should-run-build=True" >> "$GITHUB_OUTPUT"
            echo "#### Found features/fixes. Bumping a git tag version! :punch:" >> $GITHUB_STEP_SUMMARY
          else
            echo "should-run-build=False" >> "$GITHUB_OUTPUT"
            echo "#### No features, no fixes. Skipping Build job :police_car:" >> $GITHUB_STEP_SUMMARY
          fi

  build:
    runs-on: ubuntu-latest
    needs: git-tag-release
    if: false  # Skip because this is a template
    # if: needs.git-tag-release.outputs.should-run-build == 'True'
    permissions:
      contents: read
      # packages: write
      id-token: write  # This is required for requesting the JWT
    outputs:
      COMMIT_TAG: ${{ steps.fetch-tags.outputs.COMMIT_TAG }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetching Git tags
        id: fetch-tags
        run: |
          git fetch --tags
          COMMIT_TAG=$(git tag --points-at HEAD)    # Find tags associated with the current commit. Normally there is one tag only.
          echo $COMMIT_TAG
          echo "COMMIT_TAG=$COMMIT_TAG" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }} # Set via GitHub Secrets and variables on a org level
          role-to-assume:  ${{ vars.AWS_ECR_ROLE_ARN }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Collect Docker Tags
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY_OWNER_AND_REPO: ${{ github.repository }}
          REF_NAME: ${{ github.ref_name }}  # This is a branch or tag name
        run: |
            # Initialize the tags with SHA, branch/tag name, and 'latest'
            DOCKER_TAGS="$REGISTRY/$APP_NAME:${{ github.sha }}"
            DOCKER_TAGS="$DOCKER_TAGS,$REGISTRY/$APP_NAME:$REF_NAME"
            DOCKER_TAGS="$DOCKER_TAGS,$REGISTRY/$APP_NAME:latest"

            COMMIT_TAG="${{ steps.fetch-tags.outputs.COMMIT_TAG }}"

            if [ -n "${COMMIT_TAG}" ]; then
              echo Adding "$COMMIT_TAG" Docker tag
              DOCKER_TAGS="$DOCKER_TAGS,$REGISTRY/$APP_NAME:$COMMIT_TAG"
            fi

            echo Saving Docker tags: $DOCKER_TAGS
            echo "DOCKER_TAGS=$DOCKER_TAGS" >> $GITHUB_ENV

      - name: Build and push Docker image to ECR
        uses: docker/build-push-action@v5
        with:
          push: true
          tags: ${{ env.DOCKER_TAGS }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    env:
      TIMEOUT: 300 # seconds
      RETRY_LIMIT: 3
    environment: # https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment
      name: ${{ github.ref_name }}
      url: https://${{ vars.APP_NAME }}.${{ vars.DNS_ZONE }}
    concurrency: ${{ github.ref_name }}
    steps:
      - uses: actions/checkout@v4
      - name: Install ArgoCD
        run: |
          VERSION=$(curl -L -s https://raw.githubusercontent.com/argoproj/argo-cd/stable/VERSION)
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v$VERSION/argocd-linux-amd64
          install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64
      - name: Update app version
        id: deploy
        env:
          ARGOCD_SERVER: ${{ vars.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
          ARGOCD_OPTS: "--grpc-web"
        Construction HTTPS_REPO_URL because ${{ github.repositoryUrl }} uses git:// protocol
        run: |
          HTTPS_REPO_URL="https://github.com/${{ github.repository }}.git" 
          ARGOCD_APP=$(argocd app list --repo ${HTTPS_REPO_URL} --project ${{ github.ref_name }} --output name)

          echo "BACKUP_TAG=$(argocd app get $ARGOCD_APP -o json | jq -r '.spec.source.targetRevision')" >> $GITHUB_OUTPUT

          COMMIT_TAG="${{ needs.build.outputs.COMMIT_TAG }}"

          echo "#### Setting new tag $COMMIT_TAG on $ARGOCD_APP" >> $GITHUB_STEP_SUMMARY
          argocd app set ${ARGOCD_APP} --helm-set global.deployment.image.tag=${COMMIT_TAG}
          argocd app sync ${ARGOCD_APP} --timeout ${{ env.TIMEOUT }}  --retry-limit=${{ env.RETRY_LIMIT }}

          STATUS=$(argocd app get $ARGOCD_APP -o json | jq -r '.status.health.status')
          echo "STATUS=${STATUS}" >> $GITHUB_OUTPUT

      - name: Rollback on failure
        if: ${{ steps.deploy.outputs.STATUS == 'Degraded' }}
        run: |
          HTTPS_REPO_URL="https://github.com/${{ github.repository }}.git"
          ARGOCD_APP=$(argocd app list --repo ${HTTPS_REPO_URL} --project ${{ github.ref_name }} --output name)

          echo  "#### Deployment failed, rolling back..." >> $GITHUB_STEP_SUMMARY
          argocd app set $ARGOCD_APP --helm-set global.deployment.image.tag=${{ steps.deploy.outputs.BACKUP_TAG }}
          argocd app sync $ARGOCD_APP --timeout ${{ env.TIMEOUT }} --retry-limit=${{ env.RETRY_LIMIT }}

          echo "#### Rolled back $ARGOCD_APP to $BACKUP_TAG" >> $GITHUB_STEP_SUMMARY
